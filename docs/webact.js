var w=Object.freeze,L=Object.defineProperty;var g=(s,e)=>w(L(s,"raw",{value:w(e||s.slice())}));function E(s){return s.replace(/(-)([a-z])/g,e=>e[1].toUpperCase())}function d(s){return s.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase()}function c(s){return s?Array.from(s).reduce((e,{localName:r,value:n})=>Object.assign(e,{[E(r)]:n}),{}):{}}function u(s){return document.createRange().createContextualFragment(s)}function S(s,...e){let r=new CSSStyleSheet;return r.replace(String.raw(s,...e)),r}function P(s,...e){return u(String.raw(s,...e))}var o=new Map,i=new Map;var _=class s extends HTMLElement{constructor(e){super(),e?this.componentPath=e:(console.warn("You did not send a path to the super method in your constructor. Thus CSS and HTML cannot be read for this component.",this),console.warn("If shipping for modern browser, then call super with import.meta.url. If not, specify a path that is similar to import.meta.url yourself."),console.warn("Should be the path to the component you are making."))}render(e){}$(e){return this._sDOM.querySelector(e)}get cssPath(){var e;return(e=this.componentPath)==null?void 0:e.replace(/\.(html|js)/gi,".css")}get htmlPath(){var e;return(e=this.componentPath)==null?void 0:e.replace(/\.(css|js)/gi,".html")}get props(){return c(this.attributes)}async _render(){let e=await this.fetchCSSAsStyleSheet();this._sDOM.adoptedStyleSheets=[e];let r=this.render(this.props);return u(r)}async fetchHTMLAsDocFrag(){if(i.has(this.htmlPath))return i.get(this.htmlPath);let e=await fetch(this.htmlPath);if(e.ok&&e.headers.get("content-type").includes("text/html")){let r=await e.text(),n=u(r);return i.set(this.htmlPath,n),n}throw new Error("Fetch failed")}async fetchCSSAsStyleSheet(){if(o.has(this.cssPath))return o.get(this.cssPath);let e=new CSSStyleSheet,r=await fetch(this.cssPath);if(r.ok&&r.headers.get("content-type").includes("text/css")){let n=await r.text();await e.replace(n),o.set(this.cssPath,e)}return e}async _renderHTMLFile(){let[e,r]=await Promise.all([this.fetchHTMLAsDocFrag(),this.fetchCSSAsStyleSheet()]);return this._sDOM.adoptedStyleSheets=[r],e.cloneNode(!0)}componentDidMount(){}async connectedCallback(){this._sDOM=this.attachShadow({mode:"closed"});let e;this.render!==s.prototype.render?e=await this._render():this.componentPath?e=await this._renderHTMLFile():console.error("No render function or component path found for static html/css."),this._sDOM.innerHTML="",this._sDOM.appendChild(e),this.componentDidMount&&queueMicrotask(()=>this.componentDidMount())}};function y(s,{name:e}={name:void 0}){let r="is"in s?s.is:s.prototype.constructor.name,n=e||d(r);return customElements.define(n,s),n}var M=[],C=new Map,m=new Map,p=new Map,x=new Map,T,F;function A(s,{metaUrl:e,observedAttributes:r,name:n,shadowRootMode:f}){return class extends HTMLElement{constructor(){super(),this._postRender=void 0,this._propsChanged=void 0,this._hmrUpdate=!1,this._componentPath=e,this._hasRendered=!1,document.addEventListener("esm-hmr:webact-function-component",()=>{this._hmrUpdate=!0,s=C.has(n)?C.get(n):s,this._render(this._props)})}set _html(t){if(!i.has(this.htmlPath)||this._hmrUpdate){let h=document.createElement("template");h.content.appendChild(t);let a=h.content;i.set(this.htmlPath,a)}}get _html(){return i.has(this.htmlPath)?i.get(this.htmlPath):null}set _css(t){(!o.has(this.htmlPath)||this._hmrUpdate)&&o.set(this.htmlPath,t)}get _css(){return o.has(this.htmlPath)?o.get(this.htmlPath):null}get cssPath(){var t;return(t=this._componentPath)==null?void 0:t.replace(/\.(html|js)/gi,".css")}get htmlPath(){var t;return(t=this._componentPath)==null?void 0:t.replace(/\.(css|js)/gi,".html")}static get observedAttributes(){return r}async _render(t){this._rendering=s.apply(this.customThis,[t]),this._rendering instanceof Promise&&await this._rendering,requestAnimationFrame(()=>{o.has(this.cssPath)?"adoptedStyleSheets"in this._sDOM&&(this._sDOM.adoptedStyleSheets=[o.get(this.cssPath)]):document.location.href.includes("localhost")&&console.warn("<".concat(n,">: Missing CSS. Will render without it.")),i.has(this.htmlPath)?this._sDOM.appendChild(i.get(this.htmlPath).cloneNode(!0)):document.location.href.includes("localhost")&&console.warn("<".concat(n,">: Missing HTML. Will render without it.")),this._postRender instanceof Function&&requestAnimationFrame(()=>{this._postRender(),this._hmrUpdate=!1,this._hasRendered=!0})})}get _props(){return c(this.attributes)}get customThis(){return{html:(t,...h)=>{if(!(i.has(this.htmlPath)&&this._hmrUpdate===!1))return i.set(this.htmlPath,P(t,...h)),i.get(this.htmlPath)},css:(t,...h)=>{if(!(o.has(this.cssPath)&&this._hmrUpdate===!1))return o.set(this.cssPath,S(t,...h)),o.get(this.cssPath)},useHTML:t=>{if(m.has(n))return m.get(n);if(t=t||this.htmlPath,!t)return;t instanceof URL&&(t=t.toString());let a=(async()=>{let l=await(await fetch(t)).text();this.customThis.html(T||(T=g(["",""])),l),m.delete(n);let R=document.createRange().createContextualFragment(l);i.set(this.htmlPath,R)})();return m.set(n,a),a},useCSS:t=>{if(p.has(n))return p.get(n);if(t=t||this.cssPath,!t)return;t instanceof URL&&(t=t.toString());let a=(async()=>{let l=await(await fetch(t)).text();o.set(this.cssPath,S(F||(F=g(["",""])),l)),p.delete(n)})();return p.set(n,a),a},postRender:t=>{this._postRender=t},deRender:t=>{this._deRender=t},propsChanged:t=>{this._propsChanged=t},$:t=>t===void 0||t===":host"?this:t===":root"?this._sDOM:this._sDOM.querySelector(t),$$:t=>this._sDOM.querySelectorAll(t)}}async attributeChangedCallback(){if(this._rendering instanceof Promise&&await this._rendering,this._propsChanged instanceof Function){let t=JSON.stringify(c(this.attributes));if(x.get(n)===t)return;requestAnimationFrame(()=>{this._propsChanged(c(this.attributes)),x.set(n,t)})}else document.location.href.includes("localhost")&&console.error("\n          <".concat(n,">: Attribute has changed and you are observing attributes, but not handling them in a propsChanged handler.\n          Remove observedAttributes or or actually use them.\n        "))}connectedCallback(){this._sDOM=this.attachShadow({mode:f||"closed"}),this._render(this._props)}disconnectedCallback(){this._deRender&&this._deRender()}}}function O(s,{metaUrl:e,observedAttributes:r,name:n,shadowRootMode:f}={metaUrl:void 0,observedAttributes:[],name:void 0,shadowRootMode:"closed"}){let t=n||d(s.name);if(customElements.get(t))if(M.includes(t))C.set(t,s),document.dispatchEvent(new CustomEvent("esm-hmr:webact-function-component"));else throw new Error("\n        Some else has already registered <".concat(t,"> in the custom element registry.\n      "));else{let h=A(s,{metaUrl:e,observedAttributes:r,name:t,shadowRootMode:f});customElements.define(t,h),M.push(t)}return t}export{_ as Component,y as registerComponent,O as registerFunctionComponent};
//# sourceMappingURL=index.js.map
