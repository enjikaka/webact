var P=Object.freeze,v=Object.defineProperty;var S=(n,e)=>P(v(n,"raw",{value:P(e||n.slice())}));function D(n){return n.replace(/(-)([a-z])/g,e=>e[1].toUpperCase())}function p(n){return n.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase()}function u(n){return n?Array.from(n).reduce((e,{localName:r,value:s})=>Object.assign(e,{[D(r)]:s}),{}):{}}function f(n){return document.createRange().createContextualFragment(n)}function y(n,...e){let r=new CSSStyleSheet;return r.replace(String.raw(n,...e)),r}function M(n,...e){return f(String.raw(n,...e))}var d=class{constructor(e){this.root=e,this.byType=new Map}on(e,r,s,c){this.byType.has(e)||(this.byType.set(e,[]),this.root.addEventListener(e,this,c)),this.byType.get(e).push({selector:r,fn:s})}offAll(){for(let e of this.byType.keys())this.root.removeEventListener(e,this);this.byType.clear()}handleEvent(e){var s,c,t;let r=this.byType.get(e.type);if(r)for(let{selector:h,fn:a}of r){let l=(c=(s=e.target)==null?void 0:s.closest)==null?void 0:c.call(s,h);l&&(this.root===((t=l.getRootNode)==null?void 0:t.call(l))||this.root.contains(l))&&a.call(l,e)}}};var o=new Map,i=new Map;var w=class n extends HTMLElement{constructor(e){super(),e?this.componentPath=e:(console.warn("You did not send a path to the super method in your constructor. Thus CSS and HTML cannot be read for this component.",this),console.warn("If shipping for modern browser, then call super with import.meta.url. If not, specify a path that is similar to import.meta.url yourself."),console.warn("Should be the path to the component you are making."))}render(e){}deRender(){}$(e){return this._sDOM.querySelector(e)}get cssPath(){var e;return(e=this.componentPath)==null?void 0:e.replace(/\.(html|js)/gi,".css")}get htmlPath(){var e;return(e=this.componentPath)==null?void 0:e.replace(/\.(css|js)/gi,".html")}get props(){return u(this.attributes)}async _render(){let e=await this.fetchCSSAsStyleSheet();this._sDOM.adoptedStyleSheets=[e];let r=this.render(this.props);return f(r)}_deRender(){this.deRender&&this.deRender()}async fetchHTMLAsDocFrag(){if(i.has(this.htmlPath))return i.get(this.htmlPath);let e=await fetch(this.htmlPath);if(e.ok&&e.headers.get("content-type").includes("text/html")){let r=await e.text(),s=f(r);return i.set(this.htmlPath,s),s}throw new Error("Fetch failed")}async fetchCSSAsStyleSheet(){if(o.has(this.cssPath))return o.get(this.cssPath);let e=new CSSStyleSheet,r=await fetch(this.cssPath);if(r.ok&&r.headers.get("content-type").includes("text/css")){let s=await r.text();await e.replace(s),o.set(this.cssPath,e)}return e}async _renderHTMLFile(){let[e,r]=await Promise.all([this.fetchHTMLAsDocFrag(),this.fetchCSSAsStyleSheet()]);return this._sDOM.adoptedStyleSheets=[r],e.cloneNode(!0)}componentDidMount(){}on(e,r,s,c){return this._events.on(e,r,s,c)}offAll(){this._events.offAll()}async connectedCallback(){this._sDOM=this.attachShadow({mode:"closed"}),this._events=new d(this._sDOM);let e;this.render!==n.prototype.render?e=await this._render():this.componentPath?e=await this._renderHTMLFile():console.error("No render function or component path found for static html/css."),this._sDOM.innerHTML="",this._sDOM.appendChild(e),this.componentDidMount&&queueMicrotask(()=>this.componentDidMount())}disconnectedCallback(){var e;(e=this._events)==null||e.offAll(),this._deRender&&this._deRender()}};function T(n,{name:e}={name:void 0}){let r="is"in n?n.is:n.prototype.constructor.name,s=e||p(r);return customElements.define(s,n),s}var x=[],C=new Map,g=new Map,_=new Map,R=new Map,F,b;function E(n,{metaUrl:e,observedAttributes:r,name:s,shadowRootMode:c}){return class extends HTMLElement{constructor(){super(),this._postRender=void 0,this._propsChanged=void 0,this._hmrUpdate=!1,this._componentPath=e,this._customThis=null,this._hasRendered=!1,document.addEventListener("esm-hmr:webact-function-component",()=>{this._hmrUpdate=!0,n=C.has(s)?C.get(s):n,this._render(this._props)})}set _html(t){if(!i.has(this.htmlPath)||this._hmrUpdate){let h=document.createElement("template");h.content.appendChild(t);let a=h.content;i.set(this.htmlPath,a)}}get _html(){return i.has(this.htmlPath)?i.get(this.htmlPath):null}set _css(t){(!o.has(this.htmlPath)||this._hmrUpdate)&&o.set(this.htmlPath,t)}get _css(){return o.has(this.htmlPath)?o.get(this.htmlPath):null}get cssPath(){var t;return(t=this._componentPath)==null?void 0:t.replace(/\.(html|js)/gi,".css")}get htmlPath(){var t;return(t=this._componentPath)==null?void 0:t.replace(/\.(css|js)/gi,".html")}static get observedAttributes(){return r}async _render(t){this._rendering=n.apply(this.customThis,[t]),this._rendering instanceof Promise&&await this._rendering,requestAnimationFrame(()=>{o.has(this.cssPath)?"adoptedStyleSheets"in this._sDOM&&(this._sDOM.adoptedStyleSheets=[o.get(this.cssPath)]):document.location.href.includes("localhost")&&console.warn("<".concat(s,">: Missing CSS. Will render without it.")),i.has(this.htmlPath)?this._sDOM.appendChild(i.get(this.htmlPath).cloneNode(!0)):document.location.href.includes("localhost")&&console.warn("<".concat(s,">: Missing HTML. Will render without it.")),this._postRender instanceof Function&&requestAnimationFrame(()=>{this._postRender(),this._hmrUpdate=!1,this._hasRendered=!0})})}get _props(){return u(this.attributes)}get customThis(){return this._customThis?this._customThis:(this._customThis={html:(t,...h)=>{if(!(i.has(this.htmlPath)&&this._hmrUpdate===!1))return i.set(this.htmlPath,M(t,...h)),i.get(this.htmlPath)},css:(t,...h)=>{if(!(o.has(this.cssPath)&&this._hmrUpdate===!1))return o.set(this.cssPath,y(t,...h)),o.get(this.cssPath)},useHTML:t=>{if(g.has(s))return g.get(s);if(t=t||this.htmlPath,!t)return;t instanceof URL&&(t=t.toString());let a=(async()=>{let m=await(await fetch(t)).text();this.customThis.html(F||(F=S(["",""])),m),g.delete(s);let O=document.createRange().createContextualFragment(m);i.set(this.htmlPath,O)})();return g.set(s,a),a},useCSS:t=>{if(_.has(s))return _.get(s);if(t=t||this.cssPath,!t)return;t instanceof URL&&(t=t.toString());let a=(async()=>{let m=await(await fetch(t)).text();o.set(this.cssPath,y(b||(b=S(["",""])),m)),_.delete(s)})();return _.set(s,a),a},postRender:t=>{this._postRender=t},deRender:t=>{this._deRender=t},propsChanged:t=>{this._propsChanged=t},$:t=>t===void 0||t===":host"?this:t===":root"?this._sDOM:this._sDOM.querySelector(t),$$:t=>this._sDOM.querySelectorAll(t),on:(t,h,a,l)=>this._events.on(t,h,a,l),offAll:()=>this._events.offAll()},this._customThis)}async attributeChangedCallback(){if(this._rendering instanceof Promise&&await this._rendering,this._propsChanged instanceof Function){let t=JSON.stringify(u(this.attributes));if(R.get(s)===t)return;requestAnimationFrame(()=>{this._propsChanged(u(this.attributes)),R.set(s,t)})}else document.location.href.includes("localhost")&&console.error("\n          <".concat(s,">: Attribute has changed and you are observing attributes, but not handling them in a propsChanged handler.\n          Remove observedAttributes or or actually use them.\n        "))}connectedCallback(){this._sDOM=this.attachShadow({mode:c||"closed"}),this._events=new d(this._sDOM),this._render(this._props)}disconnectedCallback(){var t;(t=this._events)==null||t.offAll(),this._deRender&&this._deRender()}}}function A(n,{metaUrl:e,observedAttributes:r,name:s,shadowRootMode:c}={metaUrl:void 0,observedAttributes:[],name:void 0,shadowRootMode:"closed"}){let t=s||p(n.name);if(customElements.get(t))if(x.includes(t))C.set(t,n),document.dispatchEvent(new CustomEvent("esm-hmr:webact-function-component"));else throw new Error("\n        Some else has already registered <".concat(t,"> in the custom element registry.\n      "));else{let h=E(n,{metaUrl:e,observedAttributes:r,name:t,shadowRootMode:c});customElements.define(t,h),x.push(t)}return t}export{w as Component,T as registerComponent,A as registerFunctionComponent};
//# sourceMappingURL=index.js.map
