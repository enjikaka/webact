function T(s){return s.replace(/(-)([a-z])/g,e=>e[1].toUpperCase())}function l(s){return s.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase()}function c(s){return s?Array.from(s).reduce((e,{localName:r,value:n})=>Object.assign(e,{[T(r)]:n}),{}):{}}function d(s){return document.createRange().createContextualFragment(s)}function S(s,...e){let r=new CSSStyleSheet;return r.replace(String.raw(s,...e)),r}function C(s,...e){return d(String.raw(s,...e))}var o=new Map,h=new Map;var f=class s extends HTMLElement{constructor(e){super(),e?this.componentPath=e:(console.warn("You did not send a path to the super method in your constructor. Thus CSS and HTML cannot be read for this component.",this),console.warn("If shipping for modern browser, then call super with import.meta.url. If not, specify a path that is similar to import.meta.url yourself."),console.warn("Should be the path to the component you are making."))}render(e){}$(e){return this._sDOM.querySelector(e)}get cssPath(){var e;return(e=this.componentPath)==null?void 0:e.replace(/\.(html|js)/gi,".css")}get htmlPath(){var e;return(e=this.componentPath)==null?void 0:e.replace(/\.(css|js)/gi,".html")}get props(){return c(this.attributes)}async _render(){let e=await this.fetchCSSAsStyleSheet();this._sDOM.adoptedStyleSheets=[e];let r=this.render(this.props);return d(r)}async fetchHTMLAsDocFrag(){if(h.has(this.htmlPath))return h.get(this.htmlPath);let e=await fetch(this.htmlPath);if(e.ok&&e.headers.get("content-type").includes("text/html")){let r=await e.text(),n=d(r);return h.set(this.htmlPath,n),n}throw new Error("Fetch failed")}async fetchCSSAsStyleSheet(){if(o.has(this.cssPath))return o.get(this.cssPath);let e=new CSSStyleSheet,r=await fetch(this.cssPath);if(r.ok&&r.headers.get("content-type").includes("text/css")){let n=await r.text();await e.replace(n),o.set(this.cssPath,e)}return e}async _renderHTMLFile(){let[e,r]=await Promise.all([this.fetchHTMLAsDocFrag(),this.fetchCSSAsStyleSheet()]);return this._sDOM.adoptedStyleSheets=[r],e.cloneNode(!0)}componentDidMount(){}async connectedCallback(){this._sDOM=this.attachShadow({mode:"closed"});let e;this.render!==s.prototype.render?e=await this._render():this.componentPath?e=await this._renderHTMLFile():console.error("No render function or component path found for static html/css."),this._sDOM.innerHTML="",this._sDOM.appendChild(e),this.componentDidMount&&queueMicrotask(()=>this.componentDidMount())}};function w(s,{name:e}={name:void 0}){let r="is"in s?s.is:s.prototype.constructor.name,n=e||l(r);return customElements.define(n,s),n}var y=[],_=new Map,g=new Map,u=new Map,M=new Map;function F(s,{metaUrl:e,observedAttributes:r,name:n,shadowRootMode:m}){return class extends HTMLElement{constructor(){super(),this._postRender=void 0,this._propsChanged=void 0,this._hmrUpdate=!1,this._componentPath=e,this._hasRendered=!1,document.addEventListener("esm-hmr:webact-function-component",()=>{this._hmrUpdate=!0,s=_.has(n)?_.get(n):s,this._render(this._props)})}set _html(t){if(!h.has(this.htmlPath)||this._hmrUpdate){let i=document.createElement("template");i.content.appendChild(t);let a=i.content;h.set(this.htmlPath,a)}}get _html(){return h.has(this.htmlPath)?h.get(this.htmlPath):null}set _css(t){(!o.has(this.htmlPath)||this._hmrUpdate)&&o.set(this.htmlPath,t)}get _css(){return o.has(this.htmlPath)?o.get(this.htmlPath):null}get cssPath(){var t;return(t=this._componentPath)==null?void 0:t.replace(/\.(html|js)/gi,".css")}get htmlPath(){var t;return(t=this._componentPath)==null?void 0:t.replace(/\.(css|js)/gi,".html")}static get observedAttributes(){return r}async _render(t){this._rendering=s.apply(this.customThis,[t]),this._rendering instanceof Promise&&await this._rendering,requestAnimationFrame(()=>{this._css?("adoptedStyleSheets"in this._sDOM&&this._css instanceof CSSStyleSheet&&(this._sDOM.adoptedStyleSheets=[this._css]),this._css instanceof HTMLStyleElement&&this._sDOM.appendChild(this._css)):document.location.href.includes("localhost")&&console.warn(`<${n}>: Missing CSS. Will render without it.`),this._html?this._sDOM.appendChild(this._html):document.location.href.includes("localhost")&&console.warn(`<${n}>: Missing HTML. Will render without it.`),this._postRender instanceof Function&&requestAnimationFrame(()=>{this._postRender(),this._hmrUpdate=!1,this._hasRendered=!0})})}get _props(){return c(this.attributes)}get customThis(){return{html:(t,...i)=>{if(!(this._html!==null&&this._hmrUpdate===!1))return this._html=C(t,...i),this._html},css:(t,...i)=>{if(!(this._css!==null&&this._hmrUpdate===!1))return this._css=S(t,...i),this._css},useHTML:t=>{if(g.has(n))return g.get(n);if(t=t||this.htmlPath,!t)return;t instanceof URL&&(t=t.toString());let a=(async()=>{let p=await(await fetch(t)).text();this.customThis.html`${p}`})();return g.set(n,a),a},useCSS:t=>{if(u.has(n))return u.get(n);if(t=t||this.cssPath,!t)return;t instanceof URL&&(t=t.toString());let a=(async()=>{let p=await(await fetch(t)).text();this.customThis.css`${p}`,u.delete(n)})();return u.set(n,a),a},postRender:t=>{this._postRender=t},deRender:t=>{this._deRender=t},propsChanged:t=>{this._propsChanged=t},$:t=>t===void 0||t===":host"?this:t===":root"?this._sDOM:this._sDOM.querySelector(t),$$:t=>this._sDOM.querySelectorAll(t)}}async attributeChangedCallback(){if(this._rendering instanceof Promise&&await this._rendering,this._propsChanged instanceof Function){let t=JSON.stringify(c(this.attributes));if(M.get(n)===t)return;requestAnimationFrame(()=>{this._propsChanged(c(this.attributes)),M.set(n,t)})}else document.location.href.includes("localhost")&&console.error(`
          <${n}>: Attribute has changed and you are observing attributes, but not handling them in a propsChanged handler.
          Remove observedAttributes or or actually use them.
        `)}connectedCallback(){this._sDOM=this.attachShadow({mode:m||"closed"}),this._render(this._props)}disconnectedCallback(){this._deRender&&this._deRender()}}}function P(s,{metaUrl:e,observedAttributes:r,name:n,shadowRootMode:m}={metaUrl:void 0,observedAttributes:[],name:void 0,shadowRootMode:"closed"}){let t=n||l(s.name);if(customElements.get(t))if(y.includes(t))_.set(t,s),document.dispatchEvent(new CustomEvent("esm-hmr:webact-function-component"));else throw new Error(`
        Some else has already registered <${t}> in the custom element registry.
      `);else{let i=F(s,{metaUrl:e,observedAttributes:r,name:t,shadowRootMode:m});customElements.define(t,i),y.push(t)}return t}export{f as Component,w as registerComponent,P as registerFunctionComponent};
//# sourceMappingURL=index.js.map
