var R=Object.defineProperty,A=Object.defineProperties;var L=Object.getOwnPropertyDescriptors;var w=Object.getOwnPropertySymbols;var H=Object.prototype.hasOwnProperty,U=Object.prototype.propertyIsEnumerable;var C=(s,t,n)=>t in s?R(s,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):s[t]=n,y=(s,t)=>{for(var n in t||(t={}))H.call(t,n)&&C(s,n,t[n]);if(w)for(var n of w(t))U.call(t,n)&&C(s,n,t[n]);return s},M=(s,t)=>A(s,L(t));function $(s){return s.replace(/(-)([a-z])/g,t=>t[1].toUpperCase())}function c(s){return s.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase()}function i(s){return s?Array.from(s).reduce((t,{localName:n,value:r})=>M(y({},t),{[$(n)]:r}),{}):{}}function a(s){return document.createRange().createContextualFragment(s)}function v(s,...t){let n=new CSSStyleSheet;return n.replace(String.raw(s,...t)),n}function j(s,...t){let n=document.createElement("style");return n.innerText=String.raw(s,...t),n}function x(s,...t){let n=!1;try{new CSSStyleSheet,n=!0}catch(r){n=!1}return n?v(s,...t):j(s,...t)}function T(s,...t){return a(String.raw(s,...t))}var f={},q={},_=class extends HTMLElement{constructor(t){super(),t?this.componentPath=t:(console.warn("You did not send a path to the super method in your constructor. Thus CSS and HTML cannot be read for this component.",this),console.warn("If shipping for modern browser, then call super with import.meta.url. If not, specify a path that is similar to import.meta.url yourself."),console.warn("Should be the path to the component you are making."))}render(t){}$(t){return this._sDOM.querySelector(t)}get cssPath(){return this.componentPath&&this.componentPath.replace(/\.(html|js)/gi,".css")}get htmlPath(){return this.componentPath&&this.componentPath.replace(/\.(css|js)/gi,".html")}get props(){return i(this.attributes)}async _render(){if(!q[this.cssPath]&&this.cssPath){let r=await this.fetchCSSAsStyleSheet();this._sDOM.adoptedStyleSheets=[r]}let n=this.render(this.props);return a(n)}async fetchHTMLAsDocFrag(){let t=await fetch(this.htmlPath);if(t.ok){let n=await t.text();return a(n)}throw new Error("Fetch failed")}async fetchCSSAsStyleSheet(){let t=new CSSStyleSheet,n=await fetch(this.cssPath);if(n.ok&&n.headers.get("content-type").indexOf("text/css")!==-1){let r=await n.text();await t.replace(r)}return t}async _renderHTMLFile(){let t=btoa(this.componentPath);f[t]||(f[t]=Promise.all([this.fetchHTMLAsDocFrag(),this.fetchCSSAsStyleSheet()]));let[n,r]=await f[t];return this._sDOM.adoptedStyleSheets=[r],n.cloneNode(!0)}componentDidMount(){}async connectedCallback(){this._sDOM=this.attachShadow({mode:"closed"});let t;this.render&&this.render(this.props)!==void 0?t=await this._render():this.componentPath?t=await this._renderHTMLFile():console.error("No render function or component path found for static html/css."),this._sDOM.innerHTML=null,this._sDOM.appendChild(t),requestAnimationFrame(()=>{this.componentDidMount&&this.componentDidMount()})}};function P(s,{name:t}={name:void 0}){let n="is"in s?s.is:s.prototype.constructor.name,r=t||c(n);return customElements.define(r,s),r}var F=[],S=new Map,l=new Map,d=new Map,u=new Map,g=new Map,O=new Map;function z(s,{metaUrl:t,observedAttributes:n,name:r,shadowRootMode:p}){return class extends HTMLElement{constructor(){super(),this._postRender=void 0,this._propsChanged=void 0,this._hmrUpdate=!1,this._componentPath=t,this._hasRendered=!1,document.addEventListener("esm-hmr:webact-function-component",()=>{this._hmrUpdate=!0,s=S.has(r)?S.get(r):s,this._render(this._props)})}set _html(e){if(!l.has(r)||this._hmrUpdate){let o=document.createElement("template");o.content.appendChild(e),l.set(r,o)}}get _html(){return l.has(r)?l.get(r).content.cloneNode(!0):null}set _css(e){(!d.has(r)||this._hmrUpdate)&&d.set(r,e)}get _css(){return d.has(r)?d.get(r):null}get cssPath(){return this._componentPath&&this._componentPath.replace(/\.(html|js)/gi,".css")}get htmlPath(){return this._componentPath&&this._componentPath.replace(/\.(css|js)/gi,".html")}static get observedAttributes(){return n}async _render(e){this._rendering=s.apply(this.customThis,[e]),this._rendering instanceof Promise&&await this._rendering,requestAnimationFrame(()=>{this._css?("adoptedStyleSheets"in this._sDOM&&this._css instanceof CSSStyleSheet&&(this._sDOM.adoptedStyleSheets=[this._css]),this._css instanceof HTMLStyleElement&&this._sDOM.appendChild(this._css)):document.location.href.includes("localhost")&&console.warn(`<${r}>: Missing CSS. Will render without it.`),this._html?this._sDOM.appendChild(this._html):document.location.href.includes("localhost")&&console.warn(`<${r}>: Missing HTML. Will render without it.`),this._postRender instanceof Function&&requestAnimationFrame(()=>{this._postRender(),this._hmrUpdate=!1,this._hasRendered=!0})})}get _props(){return i(this.attributes)}get customThis(){return{html:(e,...o)=>{if(!(this._html!==null&&this._hmrUpdate===!1))return this._html=T(e,...o),this._html},css:(e,...o)=>{if(!(this._css!==null&&this._hmrUpdate===!1))return this._css=x(e,...o),this._css},useHTML:e=>{if(g.has(r))return g.get(r);if(e=e||this.htmlPath,!e)return;e instanceof URL&&(e=e.toString());let h=(async()=>{let m=await(await fetch(e)).text();this.customThis.html`${m}`})();return g.set(r,h),h},useCSS:e=>{if(u.has(r))return u.get(r);if(e=e||this.cssPath,!e)return;e instanceof URL&&(e=e.toString());let h=(async()=>{let m=await(await fetch(e)).text();this.customThis.css`${m}`,u.delete(r)})();return u.set(r,h),h},postRender:e=>{this._postRender=e},deRender:e=>{this._deRender=e},propsChanged:e=>{this._propsChanged=e},$:e=>e===void 0||e===":host"?this:e===":root"?this._sDOM:this._sDOM.querySelector(e),$$:e=>this._sDOM.querySelectorAll(e)}}async attributeChangedCallback(){if(this._rendering instanceof Promise&&await this._rendering,this._propsChanged instanceof Function){let e=JSON.stringify(i(this.attributes));if(O.get(r)===e)return;requestAnimationFrame(()=>{this._propsChanged(i(this.attributes)),O.set(r,e)})}else document.location.href.includes("localhost")&&console.error(`
          <${r}>: Attribute has changed and you are observing attributes, but not handling them in a propsChanged handler.
          Remove observedAttributes or or actually use them.
        `)}connectedCallback(){this._sDOM=this.attachShadow({mode:p||"closed"}),this._render(this._props)}disconnectedCallback(){this._deRender&&this._deRender()}}}function D(s,{metaUrl:t,observedAttributes:n,name:r,shadowRootMode:p}={metaUrl:void 0,observedAttributes:[],name:void 0,shadowRootMode:"closed"}){let e=r||c(s.name);if(customElements.get(e))if(F.includes(e))S.set(e,s),document.dispatchEvent(new CustomEvent("esm-hmr:webact-function-component"));else throw new Error(`
        Some else has already registered <${e}> in the custom element registry.
      `);else{let o=z(s,{metaUrl:t,observedAttributes:n,name:e,shadowRootMode:p});customElements.define(e,o),F.push(e)}return e}export{_ as Component,P as registerComponent,D as registerFunctionComponent};
//# sourceMappingURL=index.js.map
